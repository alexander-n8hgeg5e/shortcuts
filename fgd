#!/usr/bin/env python3

from subprocess import PIPE
from subprocess import check_output 
from sys import argv
from re import search,IGNORECASE
from sys import path
path.insert(0,"/var/src/pylib")
from pylib.file_utils.split import file2list_v2
from pylib.file_utils.split import data2list
from re import match
from hashlib import sha1
from collections import OrderedDict as OD
from argparse import ArgumentParser
from pylib.list_utils import uniq
from pathlib import Path
import multiprocessing as mp

def do_file(filename):
    found=[]
    if not Path(str(filename)).is_dir():
        cmd = [ "git", "diff", ref , "--", filename ]
        lines = data2list(check_output(cmd))
        for line in lines:
            for kwd in kwds:
                if search(kwd,line,flags=IGNORECASE):
                    ignore = False
                    for ikwd in kwds_ignore:
                        # Ignore kwds/regexes need to match case.
                        # Ignoring something unintended would mean
                        # to miss a match.
                        if search(ikwd,line):
                            ignore = True
                            break
                    if not ignore:
                        hashme = b" ".join([filename,line,kwd])
                        msg=f'### regex = "{kwd}"   ###\n'
                        msg+=str(line)+"\n"
                        msg+=f'### file: "{filename}"'
                        found.append((hashme,msg))
    return found

def main():
    global ref
    global kwds
    global kwds_ignore
    redundancy = 1
    ap=ArgumentParser()
    ap.add_argument("-i","--ignore",nargs="*")
    ap.add_argument(dest="git_reference", nargs=1)
    zzz = ap.parse_args()
    ref = zzz.git_reference[0]
    kwds  = file2list_v2("~/.filterkwds")
    kwds_ignore = file2list_v2("~/.filterkwds_ignore")
    files = data2list(check_output(["git", "diff", "--name-only" , ref ]))
    pool = mp.Pool()
    
    matches2print_l = pool.map(do_file, files)
    #print(matches2print_l)
    matches2print = OD()
    for thing in matches2print_l:
        for key,val in thing:
            hashval = sha1(key).hexdigest()
            msg = val 
            matches2print[hashval]=msg
    
    hashes = list(matches2print)
    l = len(hashes[0])
    for k,v in matches2print.items():
        matches2print_without = matches2print.copy()
        matches2print_without.pop(k)
        for i in range(l-1, 0 , -1):
            if k[:i] in [ m[:i] for m in  matches2print_without]:
                break
        # actually minimum is i+1
        # to catch typos add one more
        # so in case of a typo
        # most likely nothing will be ignored
        here_minlen = i + 1 + redundancy
    
        if not zzz.ignore is None:
            do_continue=False
            for i in zzz.ignore:
                if k[:here_minlen] == i[:here_minlen]:
                    do_continue=True
                    break
            if do_continue:
                continue
        print(v)
        print(f'# hash = {k[:here_minlen]}\n')
        #print(f'# hash = {k[:here_minlen]}')

if __name__ == "__main__":
    main()




