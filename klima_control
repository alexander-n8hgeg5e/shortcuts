#!/usr/bin/python3
from pylib.syslog_utils import warn,err,info,log,WARN,ERR,INFO,warn_exp,debug,DEBUG
from syslog import LOG_LOCAL0 as LOGFACILITY,LOG_USER
from subprocess import check_call,call,check_output,DEVNULL,CalledProcessError
from time import sleep,time
from math import inf
from sys import stderr
from traceback import format_tb
from pprint import pprint

RUN_FILENAMES = [
                'klima_control_fan_running',
                'klima_control_fan_start_time',
                'klima_control_klima_running',
                'klima_control_klima_start_time',
                'klima_control_state',
                ]
USERNAME  ="klima-control"
GROUPNAME ="klima-control"

MAX_FREEZER_START_TIME=200
RATE_CHECK_AVERAGE_SEC=(30,60,90)
MIN_FREEZING_RATE_FREEZER=-0.001
MIN_FREEZING_RATE_VENTILATION=-0.0005
MAX_TIME_DELTA=60
LOOPSLEEPTIME=10
COOLDOWN_CYLCES=2
COOLDOWN_CYLCE_SLEEP=20
COOLDOWN_FINAL_FANTIME=20

STATES =    {
            "UNKNOWN"     : -1,
            "OFF"         : 0,
            "STANDBY"     : 1,
            "FREEZING"    : 2,
            "VENTILATING" : 3,
            "COOLDOWN"    : 9,
            "ANY_STATE"   : 99,
            }
for k,v in STATES.items():
    exec("{}={}".format(k,v))

state_sequence=[UNKNOWN,UNKNOWN,UNKNOWN]

sw_states = {
                "klima_running" : None,
                "fan_running"        : None,
                }
ensure_state_count=0
ENSURE_STATE_INTERVAL = 10
NUM_INITIAL_ENSURE_STATE=1

class WrongStateError(Exception):
    pass

class InvalidStartTimeError(ValueError):
    pass


#------------------------------------------#
#  low level switch state "base" functions #
#------------------------------------------#
def rf_dev_sw(devcode, on_or_off):
    if on_or_off == 'on':
        add = '1'
    elif on_or_off == 'off':
        add = '0'
    call(["rf", str(devcode) + add ],stdout=DEVNULL)
    sleep(1)
    call(["rf", str(devcode) + add ],stdout=DEVNULL)

def switch_state_tracked( state_name, state , sw_func, on_sw_action ):
    global sw_states
    was_state = sw_states[state_name]
    if not args.test:
        sw_func()
    sw_states[state_name] = state
    write_sw_state(state_name,state)
    if was_state != state:
        on_sw_action()

def write_sw_state(name,state):
    with open("/var/run/klima_control_"+name,mode="wt") as f:
        f.write(repr(state))

def read_sw_state(name):
    with open("/var/run/klima_control_"+name,mode="rt") as f:
        try:
            return eval(f.read())
        except SyntaxError:
            return UNKNOWN


#-----------------------------------#
#  low level switch state functions #
#-----------------------------------#
def _sw_klima_off():
    rf_dev_sw(24,'off')

def _sw_klima_on():
    rf_dev_sw(24,'on')

def _sw_fan_on():
    rf_dev_sw(12,'on')

def _sw_fan_off():
    rf_dev_sw(12,'off')

def sw_klima_off():
    switch_state_tracked("klima_running",False,_sw_klima_off,lambda :log_runtime("klima"))

def sw_klima_on():
    switch_state_tracked("klima_running",True,_sw_klima_on,lambda:store_start_time("klima"))

def sw_fan_on():
    switch_state_tracked("fan_running",True,_sw_fan_on,lambda:store_start_time("fan"))

def sw_fan_off():
    switch_state_tracked("fan_running",False,_sw_fan_off,lambda:log_runtime("fan"))


#------------------------------------#
# high level state "base" functions  #
#------------------------------------#
def update_state(state2update):
    global state_sequence
    # only overwrite past state if state actually differs
    if state2update != state_sequence[0]:
        ls=len(state_sequence)
        for i in range(ls-1):
            state_sequence[ls-i-1]=state_sequence[ls-i-2]
        write_state(state2update)
        state_sequence[0]=state2update

def write_state(state):                                       
    with open("/var/run/klima_control_state",mode="wt") as f: 
        f.write(str(state))                                   

def read_state():
    with open("/var/run/klima_control_state",mode="rt") as f:
        try:
            return int(f.read())
        except ValueError:
            return UNKNOWN

def _run_state_function(from_states,function_state,target_state,function):
    global state_sequence
    if not ANY_STATE in from_states:
        if not state_sequence[0] in from_states:
            raise WrongStateError   (
                                    "State should be in \"{}\", but state is \"{}\".\nfunction: {}".format(
                                    [ get_state_name(s) for s in from_states ],
                                    get_state_name(state_sequence[0]),function)
                                    )
    update_state(function_state)
    if args.verbose:
        print("state="+get_state_name(function_state))
    function()
    update_state(target_state)
    if args.verbose:
        print("state="+get_state_name(target_state))

def run_state_function(from_states,function_state,target_state,function):
    global state_sequence
    if state_sequence[0] is target_state:
        return
    _run_state_function(from_states,function_state,target_state,function)

def ensure_state(from_states,function_state,target_state,function):
    global state_sequence
    global ensure_state_count
    if state_sequence[0] != target_state:
        run_state_function(from_states,function_state,target_state,function)
        ensure_state_count=0
        update_state(target_state)
    else:
        ensure_state_count+=1
        if ensure_state_count <= NUM_INITIAL_ENSURE_STATE or ensure_state_count%ENSURE_STATE_INTERVAL==0:
            if args.verbose:
                print("ensuring state="+get_state_name(target_state)+" ... ")
            _run_state_function(from_states,function_state,target_state,function)

def get_state_name(state):
    for k,v in STATES.items():
        if v==state:
            break
    return k


#-----------------------------#
# high level state functions  #
#-----------------------------#
def _cooldown():
    sw_fan_on()
    sw_klima_off()
    for i in range(COOLDOWN_CYLCES):
        sw_klima_on()
        sleep(COOLDOWN_CYLCE_SLEEP)
        sw_klima_off()
    sleep(COOLDOWN_FINAL_FANTIME)
    sw_fan_off()

def _freeze():
    sw_fan_on()
    sw_klima_on()

def _instant_off():
    sw_klima_off()
    sw_fan_off()

def _unhealty_instant_off():
    print("UNHEALTY INSTANT OFF !",file=stderr)
    _instant_off()
    global state_sequence
    if state_sequence[0] not in [STANDBY,VENTILATING]:
        warn("Unhealty instant shutdown of klima device from state \"{}\" occured.".format(state_sequence[0]))

def instant_off():
    ensure_state([STANDBY,OFF],UNKNOWN, OFF, _instant_off)

def unhealty_standby():
    ensure_state([ANY_STATE], UNKNOWN, STANDBY, _instant_off)

def unhealty_instant_off():
    ensure_state([ANY_STATE],UNKNOWN, OFF, _unhealty_instant_off)

def cooldown():
    run_state_function([OFF,COOLDOWN,UNKNOWN,FREEZING],COOLDOWN,STANDBY,_cooldown)

def stop_ventilation():
    ensure_state([OFF,VENTILATING,STANDBY],UNKNOWN,STANDBY,sw_fan_off)

def start_ventilation():
    ensure_state([OFF,STANDBY,VENTILATING],UNKNOWN,VENTILATING,sw_fan_on)

def freeze():
    ensure_state([ANY_STATE],UNKNOWN,FREEZING,_freeze)

def ensure_standby():
    ensure_state([OFF,STANDBY],UNKNOWN,STANDBY,_instant_off)


#---------------------#
#  logging functions  #
#---------------------#
def store_start_time(name):
    with open("/var/run/klima_control_"+name+"_start_time",mode="wt") as f:
        f.write(str(time()))

def log_runtime(name):
    try:
        runtime = time() - read_start_time(name)
        prefix  = name[0].upper()+name[1:]+" " 
        postfix = " for "+str(runtime)+" seconds."
        if not args.test:
            middlefix="has run"
        else:
            middlefix="has been doing a testrun"
        msg=prefix+middlefix+postfix
        log(msg,level=INFO,facility=LOGFACILITY)
        erase_start_time(name)
    except InvalidStartTimeError:
        msg="Invalid klima start time, can not log klima runtime."
        log(msg,level=ERR,facility=LOGFACILITY)
        log(msg,level=ERR,facility=LOG_USER)

def erase_start_time(name):
    with open("/var/run/klima_control_"+name+"_start_time",mode="wt") as f:
        f.write("\"invalid\"")

def read_start_time(name):
    with open("/var/run/klima_control_"+name+"_start_time",mode="rt") as f:
        try:
            return float(f.read())
        except ValueError:
            raise InvalidStartTimeError()

#----------------------#
#  learning functions  #
#----------------------#
class State_memory():
    def __init__(self):
        self.states=[]

    def remember_temp(self,temp):
        global state_sequence
        state=  {
                'time': time(),
                'state0': state_sequence[0],
                'state1': state_sequence[1],
                'state2': state_sequence[2],
                'temp': temp,
                }
        self.states.append(state)
        if len(self.states) >= 1000:
            self.states=self.states[200:]

        self.state_working={}
        for k in STATES.keys():
            self.state_working.update({k:True})

    def get_continous_state_history(self,state_list,skip=[]):
        states=[]
        pos=-1
        ls=len(self.states)
        for _state in skip:
            while ls >= -pos and self.states[pos]['state0'] == _state:
                pos-=1
        while ls >= -pos and self.states[pos]['state0'] in state_list:
            if not self.states[pos]['temp'] is inf:
                states.append(self.states[pos])
            pos-=1
        states.reverse()

        # start at recent states
        start_index=None
        ls=len(states)
        for i in range(ls-1):
            if states[i+1]['time'] - states[i]['time'] > MAX_TIME_DELTA:
                startindex = i+1
        states=states[start_index:]

        return states

    def calc_temp_rate(self,_time,state_history):
        if len(state_history) < 2:
            debug("short state history")
            return None
        t=state_history[-1]['time']
        states=[]
        if t-state_history[0]['time'] < 0.8 * _time:
            debug("d1 dt={}".format(t-state_history[0]['time']))
            return None
        for state in state_history:
            if t - state['time'] <= _time:
                states.append(state)

        ls=len(states)
        if ls < 2:
            debug("d2")
            return None
        else:
            rates=[]
            for i in range(ls-1):
                rate = (states[i+1]['temp'] - states[i]['temp']) / (states[i+1]['time']-states[i]['time'])
                rates.append(rate)
            avg_rate=sum(rates)/len(rates)
        return avg_rate

    def state_considered_working(self,state):
        # simple check based on rate
        sh1=self.get_continous_state_history([state])
        r1  = self.calc_temp_rate(RATE_CHECK_AVERAGE_SEC[0],sh1)
        r5  = self.calc_temp_rate(RATE_CHECK_AVERAGE_SEC[1],sh1)
        r15 = self.calc_temp_rate(RATE_CHECK_AVERAGE_SEC[2],sh1)
        sh0=self.get_continous_state_history([STANDBY,OFF],skip=[state])
        s15 = self.calc_temp_rate(RATE_CHECK_AVERAGE_SEC[2],sh0)
        if None in (s15,r1,r5,r15):
            print("s15={} r1={} r5={} r15={}".format(s15,r1,r5,r15))
        else:
            print("s15={:.6f} r1={:.6f} r5={:.6f} r15={:.6f}".format(s15,r1,r5,r15))
        if not None in (r1,r5,r15,s15):
            fw1  =  -s15+r1 
            fw5  =  -s15+r5
            fw15 =  -s15+r15
            if None in (fw15,fw1,fw5):
                print("fw1={} fw5={} fw15={}".format(fw1,fw5,fw15))
            else:
                print("fw1={:.6f} fw5={:.6f} fw15={:.6f}".format(fw1,fw5,fw15))
            if state == FREEZING:
                min_freezing_rate=MIN_FREEZING_RATE_FREEZER
            elif state == VENTILATING:
                min_freezing_rate=MIN_FREEZING_RATE_VENTILATION
            else:
                min_freezing_rate=inf
            if state==FREEZING:
                for fw in (fw5,fw15):
                    if fw > min_freezing_rate*2  and time() - read_start_time("klima") > MAX_FREEZER_START_TIME:
                        warn_msg="WARNING: Freezer seems weak. Check system!"
                        warn(warn_msg)
                        print(warn_msg,file=stderr)
            if all([(fw > min_freezing_rate) for fw in (fw1,fw5,fw15)]):
                self.state_working.update({get_state_name(state) : False })
                return False
            elif all([(fw <= min_freezing_rate) for fw in (fw1,fw5,fw15)]):
                self.state_working.update({get_state_name(state) : True })
                return True
            else:
                return self.state_working[get_state_name(state)]
        else:
            return True


#-------------#
# temp sensor #
#-------------#
def get_temp():
    cmd=['get_room_temp']
    try:
        T = float(check_output(cmd).decode().strip())
    except KeyboardInterrupt:
        raise
    except Exception as e:
        print(e,file=stderr)
        T = inf
    global state_memory
    state_memory.remember_temp(T)
    return T


#----------------#
# init functions #
#----------------#
def gen_run_files():
    from subprocess import check_call
    for fn in RUN_FILENAMES:
        path="/run/"+fn
        cmd=["sudo","touch",path]
        check_call(cmd)
        cmd=["sudo","chown",USERNAME+":"+GROUPNAME,path]
        check_call(cmd)
        cmd=["sudo","chmod","g+rw",path]
        check_call(cmd)

def init():
    global state_sequence
    global sw_states
    update_state(args.state)
    if args.debug:
        print("DEBUG: init with state_sequence={}".format(state_sequence))
        print("DEBUG: init with sw_states={}".format(sw_states))
    for name in ["klima_running","fan_running"]:
        sw_states[name] = read_sw_state(name)
    if state_sequence[0] == UNKNOWN:
        print("WARNING: Init with unknown state",file=stderr)
        warn("WARNING: Init with unknown state")
        if args.fan_only:
            if args.verbose:
                print("Running cooldown to get valid state ...")
            run_handle_exception(cooldown)
    global state_memory
    state_memory=State_memory()

#-------------------#
# control functions #
#-------------------#
def print_exp(e,file=stderr):
    for line in format_tb(e.__traceback__):
        print(line,file=file)
    print("EXCEPTION("+type(e).__name__+"): "+str(e),file=file)

def run_handle_exception(function):
    try:
        function()
    except (Exception, KeyboardInterrupt) as e:
        try:
            if type(e) is KeyboardInterrupt:
                if args.verbose:
                    # newline for KeyboardInterrupt
                    print()
            else:
                warn_exp(e)
                if args.debug:
                    print_exp(e)
            if not args.fan_only:
                cooldown()
            else:
                stop_ventilation()
        except (Exception,KeyboardInterrupt) as ee:
            print(file=stderr)
            unhealty_instant_off()
            # newline for KeyboardInterrupt
            if args.debug:
                print_exp(e)
                print_exp(ee)
            warn_exp(e)
            warn_exp(ee)
    finally:
        instant_off()

def _control_loop():
    global state_memory
    target=args.target_temp
    mintemp=target-(args.hysteresis/2)
    maxtemp=target+(args.hysteresis/2)
    loop_start_time=time()
    delay = not args.disable_rate_tracking_delay
    while True:
        temp=get_temp()
        if delay and time() - loop_start_time > 1.5 * RATE_CHECK_AVERAGE_SEC[2]:
            delay=False
        if temp < mintemp:
            if args.verbose:
                print("T = "+str(temp)+"°C  low")
            if not args.fan_only:
                cooldown() #cooldown will return if allready standby or cooldown
                ensure_standby()
            else:
                stop_ventilation()
        elif temp > maxtemp: 
            if args.verbose:
                print("T = "+str(temp)+"°C  high")
                if delay:
                    print("Delaying freeze ({:.1f} [s] left), measuring room heatup rate.".format(1.5 * RATE_CHECK_AVERAGE_SEC[2] - time() + loop_start_time))
            if not delay:
                if not args.fan_only:
                    if state_memory.state_considered_working(FREEZING):
                        freeze()
                    elif time() - read_start_time("klima") > MAX_FREEZER_START_TIME:
                        err_msg="ERROR: Freezing aborted because min freezing rate not reached. Check freezing device!"
                        print(err_msg,file=stderr)
                        err(err_msg)
                        cooldown() #cooldown will return if allready standby or cooldown
                        ensure_standby()
                else:
                    if state_memory.state_considered_working(VENTILATING):
                        start_ventilation()
                    else:
                        stop_ventilation()
        else:
            if args.debug:
                print("state_sequence={}".format([get_state_name(s) for s in state_sequence]))
            if args.verbose:
                print("T = "+str(temp)+"°C  ok")

        if args.verbose:
            print("{} state considered working = {}".format(get_state_name(state_sequence[0]),state_memory.state_considered_working(state_sequence[0])))
        
        if sw_states['klima_running']:
            try:
                start_time=read_start_time("klima")
                if args.verbose:
                    print("runtime = {:.3f} [s]".format(time() - start_time))
            except ValueError:
                warn_msg="WARNING: Invalid klima runtime."
                print(warn_msg,file=stderr)
                warn(warn_msg)
    
        sleep(LOOPSLEEPTIME)

def control_loop():
    run_handle_exception(_control_loop)

def parse_args():
    from argparse import ArgumentParser
    ap=ArgumentParser()
    ap.add_argument(dest='target_temp',type=float,nargs="?",default=27)
    ap.add_argument('-sd','--shutdown',action="store_true",help="only shutdown and exit")
    ap.add_argument('--test',action="store_true",help="run test",default=False)
    ap.add_argument('--verbose',action="store_true",default=True)
    ap.add_argument('--fan-only',action="store_true",default=False)
    ap.add_argument('--debug',action="store_true",default=False)
    ap.add_argument('-R','--disable-rate-tracking-delay',action="store_true",default=False)
    ap.add_argument('--state',action="store",default=read_state())
    ap.add_argument('--hysteresis',type=float,default=1)
    ap.add_argument('--testing',action="store_true",default=False)
    ap.add_argument('-G','--gen-run-files',action="store_true",default=False)
    global args
    args=ap.parse_args()
    try:
        args.state=int(args.state)
    except ValueError:
        if args.state in STATES.keys():
            args.state=STATES[args.state]

if __name__=='__main__':
    parse_args()
    if args.gen_run_files:
        gen_run_files()
    if args.test:
        LOOPSLEEPTIME=1
        COOLDOWN_CYLCES=1
        COOLDOWN_CYLCE_SLEEP=0.4
        COOLDOWN_FINAL_FANTIME=5

        #test_temp=50.0
        #test_temp_d=0
        #def get_temp():
        #    global test_temp
        #    global test_temp_d
        #    if states[0] in (FREEZING,VENTILATING):
        #        test_temp_d-=0.005
        #    else:
        #        test_temp_d+=0.005
        #    test_temp+=test_temp_d*test_temp
        #    return test_temp
    init()
    if args.shutdown:
        cooldown()
    else:
        control_loop()

# vim: foldmethod=indent foldlevel=0 foldnestmax=2 :
