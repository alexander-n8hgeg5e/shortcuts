#!/usr/bin/python3
from re import match,sub,search,DOTALL
#from os import listdir
from os.path import isdir
from os import linesep
from pprint import pformat

MULTI_LINE_COMMENT_START = "([/][*]|--\[\[)"
MLCS=MULTI_LINE_COMMENT_START
MULTI_LINE_COMMENT_END = "([*][/]|[]][]])"
MLCE=MULTI_LINE_COMMENT_END
patterns={
        'startlinepattern' : '^(.*)'+MLCS+'[ ]*(def[ ]pystart[(][^)]*[)][:])(.*)$',
        'startline_replace_pattern_get_before' : '\\1',
        'startline_replace_pattern_get_after' : '\\4',
        'endlinepattern' : '^(.*)(pyend[ ]*'+MLCE+')(.*)$',
        'endline_replace_pattern_get_befor' : '\\1' ,
        'endline_replace_pattern_get_after' : '\\4' ,
        'at_pos_pattern' : '^(.*)'+MLCS+'[ ]*(def[ ]py[(][^)]*[)][:])(.*)'+MLCE+'(.*)$' ,
        'at_pos_replace_pattern_get_befor' : '\\1',
        'at_pos_replace_pattern_get_code' :  '\\4',
        'at_pos_replace_pattern_get_after' : '\\6',
        }

from argparse import ArgumentParser
parser=ArgumentParser( description="generates *.pyout\"[.extension]\" files from *.pyin\"[.extension]\" files")
parser.add_argument( "--verbose",'-v',action="store_true", default=False )
parser.add_argument('files', metavar='files', nargs='*', type=str, help='input filenames without extension prefix , ".pyin"  ')
parser.add_argument( "--outfile-extension-prefix",'-o',action="store",type=str ,default=".pyout",help='infile.pyin.ext will result in a outfile.outfile-extension-prefix.ext' )
parser.add_argument( "--infile-extension-prefix",'-i',action="store", type=str, default=".pyin",help='use infile.infile-extension-prefix.ext as infile' )
args=parser.parse_args()
#files=listdir()

pyprep_msg =  ('   ||*\\\\\\   *\\       /* ||*\\\\\\   ||*\\\\\\    ||====*  ||*\\\\\\   '
               '||*\\\\\\   ** |\\     *|',
               '   ||    \\\\  \\\\     //  ||    \\\\ ||    \\\\  ||       ||    \\\\ ||    '
               '\\\\ || ||\\    ||',
               '   ||    ||   \\\\   //   ||    || ||    ||  ||       ||    || ||    || || '
               '||\\\\   ||',
               '   ||   //     \\\\ //    ||   //  ||   //   ||____   ||   //  ||   //  || '
               '|| \\\\  ||',
               '   ||*//        \\//     ||*//    ||==\\\\    ||====*  ||*//    ||*//    || '
               '||  \\\\ ||',
               '   ||           //      ||       ||   \\\\   ||       ||       ||       || '
               '||   \\\\||',
               '   ||          //       ||       ||    \\\\  ||       ||       ||       || '
               '||    \\||',
               '   **         */        **       ||     \\* ||====*  **       **       ** '
                '|*     \\|'
               )

def get_code_from_oneline(m):
    p=m.groupdict()
    parts = {
            'prematch':         p["1"],
            'commentstart':     p["2"],
            'key':              p["3"],
            'code':             p["4"],
            'commentstop':      p["5"],
            'postmatch':        p["6"],
            }
    return parts

def get_code(d):
    if not d["code"] is None:
        return d["code"]
    else:
        return d["c"]

def prepare_dict(d):
    d['code'] = None
    d['c'] = None
    return d

def load(data_dict):
    if "load_path" in data_dict.keys():
        with open(data_dict['load_path'],"rt") as f:
            return data_dict.update(eval(f.read()))
    return data_dict
def store(data_dict):
    if "store_path" in data_dict.keys():
        with open(data_dict['store_path'],"wt") as f:
            f.write(pformat(data_dict))
#def use_file(file):
#    if match('[^/]+[.]c$',file) and not isdir(file):
#        return True
#    else:
#        return False

d={}
def prepfile(in_file,out_file):
    global d
    linecounter=0
    started_at = None
    code=""
    with open(out_file,mode='wt') as of:
        with open(in_file,mode='rt') as inf:
            p0=0
            p1=1
            while p1 > p0:
                p0=inf.tell()
                line=inf.readline()
                linecounter+=1
                p1=inf.tell()
                m=search(patterns['at_pos_pattern'],line)
                if not m is None:
                    parts = get_parts_from_match(m)
                    if args.verbose:
                        print("py code found at line={}, char={}".format(linecounter,len(befor)))
                        print("code: {}".format(repr(code)))

                    of.write(befor)
                    code='if True:'+code
                    if args.verbose:
                        print("    executing prep gen code:")
                        print("              ==============")
                        print(code)
                        print("-----------------code-end---")
                    d=prepare_dict(d)
                    exec(code,d,d)
                    c=get_code(d)
                    if not c is None:
                        of.write( c )
                        code=""
                    of.write( after )
                    d=load(d)

                elif match( patterns['startlinepattern'], line ):
                    # startline pattern found
                    # what is befor is normal file content
                    # that will be written to the outputfile (name here "of").
                    # What comes after "startline-keyword"
                    # will be used as start of the code
                    if args.verbose:
                        print("startline at {} : {} ".format(linecounter, repr(line) ))
                    if started_at is None:
                        started_at = p1
                        startline = linecounter
                        after=sub(patterns['startlinepattern'],patterns['startline_replace_pattern_get_after'], line ,flags=DOTALL)
                        # add to code, do not reset
                        # code should be  allready the empty string
                        # provoke errors to reveal them
                        #print("appending startline code : {} ".format( repr(after) ))
                        code+=after
                        befor=sub(patterns['startlinepattern'],patterns['startline_replace_pattern_get_before'], line,flags=DOTALL )
                        #print("writing startline content :{}".format(repr(befor)))
                        of.write(befor)
                    else:
                        raise Exception("Pyprep Syntax Error: after start follows end not start")

                elif match(patterns['endlinepattern'],line):
                    # endline pattern found
                    # what comes after the "endline-keyword"
                    # is normal file content
                    # that will be written to the outputfile (name here: "of")
                    # after the generated code will have been written.
                    # What comes befor the "endline-keyword"
                    # will be used as end of the code
                    befor=sub(patterns['endlinepattern'],patterns['endline_replace_pattern_get_befor'], line )
                    after=sub(patterns['endlinepattern'],patterns['endline_replace_pattern_get_after'], line )
                    if args.verbose:
                        print("    endline at: "+str(linecounter) )
                        #print("line:",repr(line))
                    if started_at is not None:
                        #print("appending endline code : {}".format(repr(befor)))
                        code='if True:'+code+befor
                        if args.verbose:
                            print("    executing prep gen code:")
                            print("              ==============")
                            print(code)
                            print("-----------------code-end---")
                        # as exec is a function,
                        # to get the locals of exec
                        # give it the dict "d"
                        # as locals and globals
                        d=prepare_dict(d)
                        exec(code,d,d)
                        c=get_code(d)
                        if not c is None:
                            if args.verbose:
                                print("at line {} following result will be inserted:".format(startline))
                                print("                     ======")
                                print(d['code'])
                                print("----result-end---")
                            of.write(c)
                        d=load(d)
                        code=""
                        started_at=None
                        #if args.verbose:
                        #    print("writing endline content :{}".format(repr(after)))
                        of.write(after)
                    else:
                        raise Exception("Pyprep Syntax Error:  end needs start befor")
                else:
                    if started_at is not None:
                        #print("collecting code at line {}".format(linecounter))
                        code += line
                    else:
                        #print("writing line {} :{}".format(linecounter,repr(line)))
                        of.write(line)
                #print( linecounter,end="  " )
            if not started_at is None:
                raise Exception("no end line found\n"+"startline was: "+str(startline))



files=args.files
for name in files:
    if search(".", name):
        extension=sub('.*([.][^.]+)$','\\1', name ) # inc "."
        base=sub('(^.*)[.][^.]*$','\\1', name )
    else:
        extension=""
        base=name
    infile  = base +args.infile_extension_prefix+extension
    outfile = base + args.outfile_extension_prefix+extension
    if args.verbose:
        print("generating "+outfile+" from "+infile+" ...")
    for line in pyprep_msg:
        print(line)
    prepfile( infile,outfile)
store(d)
                
                
                
 




# vim: set syntax=python foldmethod=marker    foldlevel=3    :  #{{{

