#!/usr/bin/env python3


from argparse import ArgumentParser




a=ArgumentParser()
a.add_argument("cmdline",nargs="+")
a.add_argument("-v","--verbose",action="store_true")
a.add_argument("-H","--no-header",action="store_true")
a.add_argument("-n","--nodes",nargs='+')
a.add_argument("-E","--no-exitcodes",action="store_true")
a.add_argument("-O","--no-offline-report",action="store_true")
a.add_argument("-u","--sudo-user",default="root",help="default is root, what means prepending \"sudo\". otherwise: sudo -u {value}")
a.add_argument("-r","--rils",help="prepend \"rils\",on the remote, which is a syslog logging new independent session spawning python tool",action="store_true")

args=a.parse_args()


NODESLISTFILE = "/etc/nodelist"

from sys import stderr
from sys import stdout
from sys import path
from subprocess import check_call,CalledProcessError,DEVNULL,STDOUT
from subprocess import check_output

if args.nodes is None or len(args.nodes) == 0:
    with open(NODESLISTFILE) as f:
        nodes=f.read().splitlines()
        nodes=[i.strip() for i in nodes]
        nodes=[n for n in filter(lambda x: x.strip != '' ,nodes)]
else:
    nodes=args.nodes
if not args.no_header:
    found=False
    for tty in [stdout,stderr]:
        found=tty.isatty()
        if found:
            break
    if found:
        from os import get_terminal_size
        cols=get_terminal_size(tty.fileno()).columns
    else:
        cols=20

nodes_ok=[]
for node in nodes:
    try:
        if args.verbose:
            add_to_args={}
        else:
            add_to_args={'stdout':DEVNULL,'stderr':DEVNULL}
        check_call(['ssh',node,'sh -c \'echo $(date) $(hostname) online\''],**add_to_args)
        nodes_ok.append(node)
    except CalledProcessError:
        pass

def gen_cmdline_prefixes(node):
    cmds = []
    if args.rils:
        cmds.append("rils")
    # keep cmdline short for readablity in logs
    try:
        cmd = ["ssh", node ,'id -u']
        remote_id = check_output(cmd).strip().decode()
        cmd = ['id','-u', args.sudo_user ]
        requested_id  = check_output(cmd).strip().decode()
    except:
        print(f"failed cmd: {cmd}",file=stderr)
        raise
    if remote_id != requested_id:
        if args.sudo_user == "root":
            cmds.append("sudo")
        else:
            cmds.extend(["sudo",'-u',args.sudo_user])
    return cmds

exitcodes=[]
for node in nodes_ok:
    if not args.no_header:
        header=f"# {node} #"
        header+="#"*(cols-len(node)-4)
        print(header,file=stdout)
        stdout.flush()
    try:
        # TODO: multiprocessing prior to this loop
        prefixes = gen_cmdline_prefixes(node)
        cmd = ['ssh',node] + prefixes + args.cmdline
        check_call(cmd)
        exitcodes.append((node,0))
        stderr.flush()
        stdout.flush()
    except CalledProcessError as e:
        print(f"FAILED with exit code {e.returncode}",file=stderr)
        stderr.flush()
        exitcodes.append((node,e.returncode))
if not args.no_exitcodes:
    print(f"exitcodes: {exitcodes}",file=stdout)
if not args.no_offline_report:
    print(f"nodes offline: {[n for n in filter(lambda n: n not in nodes_ok,nodes)]}",file=stdout)
exit(sum(i[-1] for i in exitcodes))
        

    





