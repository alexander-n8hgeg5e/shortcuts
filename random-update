#!/usr/bin/env python3

FAILED_FILE_PATH = "/tmp/update_failed_list"
GET_UPGRADEABLE_CMD = [ 'eix', '-I', '--format', '{upgrade=1}<category>/<name>\n{}' ]
SUCCESSFULL_END="successfull"
FAILED_END="failed"

def init():
    global LEN_FAILED_END
    global LEN_SUCCESSFULL_END
    LEN_FAILED_END=len(FAILED_END)
    LEN_SUCCESSFULL_END=len(SUCCESSFULL_END)
    parse_args()

from random import choice as random_choice
from subprocess import check_output
from subprocess import check_call
from subprocess import CalledProcessError
from subprocess import PIPE
from subprocess import DEVNULL
from argparse import ArgumentParser
from sys import stdout
from os import get_terminal_size

def parse_args():
    a=ArgumentParser()
    a.add_argument("-v","--verbose",action="store_true")
    global args
    args=a.parse_args()

class UpdateFailed(Exception):
    pass

def get_random_pkg(exclude_failed=[]):
    outp = check_output(GET_UPGRADEABLE_CMD)
    _pkgs = outp.decode().strip().split("\n")
    pkgs=[]
    for p in _pkgs:
        if not p in exclude_failed:
            lp=len(p)
            if lp > 0:
                if p[0] not in '[ ':
                    if len(p) < 5 or p[0:5] != "Found":
                        pkgs.append(p)
    if len(pkgs) > 0:
        return random_choice(pkgs)
    else:
        return None

def add_to_failed_list(pkg):
    with open(FAILED_FILE_PATH,mode="at") as f:
        f.write("\n"+pkg)
        
def get_failed_list():
    with open(FAILED_FILE_PATH,mode="rt") as f:
        return f.read().strip().split("\n")

def get_aligned_end( msg, end ):
    add_space = get_terminal_size().columns - len(msg) - end
    if add_space > 0:
        end = " " * add_space + end
    return end

def update(pkg):
    try:
        if args.verbose:
            msg="updating "+pkg+" ... "
            print(msg, end="")
            stdout.flush()
        check_call(['ionice', '-c3', 'nice', '-n19', 'sudo', 'emerge', '--ask', 'n', '--nodeps', pkg ],stdout=DEVNULL,stderr=DEVNULL)
        if args.verbose:
            print(get_aligned_end(msg,SUCCESSFULL_END)
    except CalledProcessError:
        if args.verbose:
            print(get_aligned_end(msg,FAILED_END)
        raise UpdateFailed(pkg)

def clear_failed_list():
    f = open(FAILED_FILE_PATH,mode="wt")
    f.close()
        
def main():
    init()
    while True:
        pkg=get_random_pkg(exclude_failed=get_failed_list())
        if pkg is None:
            clear_failed_list()
            continue
        else:
            try:
                update(pkg)
            except UpdateFailed:
                add_to_failed_list(pkg)

if __name__ == "__main__":
    main()
